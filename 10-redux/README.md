# 10-1. Fluxアーキテクチャ

Reactはコンポーネントを組み合わせてアプリケーションを作っていく

- 状態をもたないステートレスなコンポーネント
- 状態を持つステートフルなコンポーネント

実際のアプリケーションでは、コンポーネントをまたいで保持したい状態が存在することがよくある

ユーザーのログイン・非ログイン状態やアカウント情報など

単方向データフローでどうやって管理するのか？

- 上位のコンポーネントに必要な状態を全て持たせておいて、それらを子や孫のコンポーネントにPropsでバケツリレーしていく
  - めちゃくちゃ大変。そんなことをしている人は多分いない
- React公式が提供している `Context API`を使う
  - 使い勝手があまりよろしくないので、今の所UIテーマライブラリやi18n対応ライブラリと行った限定的な用途でしか使われていない

Reactは公式が説明しているように、もともとただのViewのライブラリ  
アプリ全体の状態管理を含めたアプリケーションのアーキテクチャをどうするのかは、各々の開発者に委ねられていた

## Flux
2014年にFacebookが発表

**MVCはスケールしない。だから私達はFluxでやる！**

フロントエンド開発では、MVCはスケールしないということ

ModelとViewの間に双方向のデータフローが作られるので、新しい機能を追加しようとするたびにシステムの複雑度が指数関数的に増大

そのコードは、**壊れやすくて予測不能なもの** になってしまう

サーバーサイドのアプリでのデータフローは、 Model => Viewの一方通行が当たり前

ユーザーの操作をインタラクティブに反映させる必要があるフロントエンドではどうしても、View => Modelのフローも必要な場面がでてくる


![Flux](https://res.infoq.com/news/2014/05/facebook-mvc-flux/ja/resources/flux-react.png)
>https://www.infoq.com/jp/news/2014/05/facebook-mvc-flux/


Storeはアプリケーション全体で保持するべき情報を蓄えたもの

Viewからはそれを適宜参照することができる

何らかのイベントが起こったときにActionという **何をどうしたいか** という意図を表現したものがViewから発行される

ActionはDispatcherによって処理され、Storeの中身が書き換えられる

Storeが変更されたら、参照していたViewにも速やかに反映される

データフローが常に単方向になることが保証される

React公式が負けがち

# 10-2. Reduxの登場

Reduxの作者はドキュメントやブログ記事の説得力がすごい

一気にデファクトスタンダードに

開発者コミュニティで人気を博したライブラリの作者を内部に取り込むというのが実質的にFacebookのReactチームの常套戦略になっている

## Reduxの何がよかったか

Reduxの三つの原則
- Single source of truth (信頼できる唯一の情報源)
  - アプリケーションの状態がただひとつのStoreオブジェクトによるツリー構造で表現されるということ
  - 複数のStoreが存在すると、Store間のデータのやり取りが面倒になるので、ひとつのオブジェクトい集約
  - シングルツリーにすることで、Undo/Redoといった機能も簡単に実装できたりする
- State is read-only (状態は読み取り専用)
  - ViewやイベントのコールバックがStoreの状態を直接書き換えることが許されない
  - Storeの変更のためには必ずActionを発行する必要がある
  - 変更がActionに集約されることで、予期せぬところからの書き換えを防いでいる
  - ReduxのActionは単なるプレーンオブジェクト
- Changes are made with pure functions (変更は純粋関数にて行われる)
  - 状態の変更は Reducer というあらかじめ定義された純粋関数によって行われるということ
  - `(prevState, action) => newState`
    - Actionが同じなら、必ず新旧の状態の差分も同じであることが保証される


Viewから発行されたActionは、Dispatcher で割り振られて Reducerに渡される

ReducerはそのActionと現在のStateを受け取って、新しいStateを返す

`reduce` -> `減らす` だが、科学の分野では `還元する` `減数分裂させる` という意味もある

`Redux`の名前の由来でもある


ReduxはActionを振り分けるだけ

Reduxでは書き換えの手順とその結果のStateの差分が厳密に定義されているので、動作の信頼性が高くテストやデバッグがやりやすい

ReduxはReact専用ではない

Reduxの公式ドキュメントには全部書いてあるから読もう

[Redux公式](https://redux.js.org/)


# 10-3. Reduxの使い方

記述が冗長なのは、規約を作ってそこに沿った部分はフレームワークが提供してあげるというやり方をしていないから

Reduxは概念を理解するのが簡単ではないし、学習コストも決して低くない

一度理解してやり方を覚えてしまうとメリットのほうが上回る

全ての場面においてReduxが必要になることはない

Local Stateで十分なときはReduxは使わなくていい

業務で開発するアプリにコンポーネントをまたいで共有したいデータがないなんてことはまずない

最初からReduxを入れておいたほうがあとからの軌道修正コストも少なくなる

このドメインのデータはStore Stateで、このドメインのデータは他の方法で管理、みたいに分けるのは Single source of truthに反していいて読みづらく破綻しやすくなるので、はじめからReduxに任せるべき
