# 10-1. Fluxアーキテクチャ

Reactはコンポーネントを組み合わせてアプリケーションを作っていく

- 状態をもたないステートレスなコンポーネント
- 状態を持つステートフルなコンポーネント

実際のアプリケーションでは、コンポーネントをまたいで保持したい状態が存在することがよくある

ユーザーのログイン・非ログイン状態やアカウント情報など

単方向データフローでどうやって管理するのか？

- 上位のコンポーネントに必要な状態を全て持たせておいて、それらを子や孫のコンポーネントにPropsでバケツリレーしていく
  - めちゃくちゃ大変。そんなことをしている人は多分いない
- React公式が提供している `Context API`を使う
  - 使い勝手があまりよろしくないので、今の所UIテーマライブラリやi18n対応ライブラリと行った限定的な用途でしか使われていない

Reactは公式が説明しているように、もともとただのViewのライブラリ  
アプリ全体の状態管理を含めたアプリケーションのアーキテクチャをどうするのかは、各々の開発者に委ねられていた

## Flux
2014年にFacebookが発表

**MVCはスケールしない。だから私達はFluxでやる！**

フロントエンド開発では、MVCはスケールしないということ

ModelとViewの間に双方向のデータフローが作られるので、新しい機能を追加しようとするたびにシステムの複雑度が指数関数的に増大

そのコードは、**壊れやすくて予測不能なもの** になってしまう

サーバーサイドのアプリでのデータフローは、 Model => Viewの一方通行が当たり前

ユーザーの操作をインタラクティブに反映させる必要があるフロントエンドではどうしても、View => Modelのフローも必要な場面がでてくる


![Flux](https://res.infoq.com/news/2014/05/facebook-mvc-flux/ja/resources/flux-react.png)
>https://www.infoq.com/jp/news/2014/05/facebook-mvc-flux/


Storeはアプリケーション全体で保持するべき情報を蓄えたもの

Viewからはそれを適宜参照することができる

何らかのイベントが起こったときにActionという **何をどうしたいか** という意図を表現したものがViewから発行される

ActionはDispatcherによって処理され、Storeの中身が書き換えられる

Storeが変更されたら、参照していたViewにも速やかに反映される

データフローが常に単方向になることが保証される

React公式が負けがち

